// Code generated by ndn tlv codegen DO NOT EDIT.
package tlv

import (
	"encoding/binary"
	"io"
	"strings"

	enc "github.com/named-data/ndnd/std/encoding"
)

type RepoCmdEncoder struct {
	Length uint

	SyncJoin_encoder SyncJoinEncoder
}

type RepoCmdParsingContext struct {
	SyncJoin_context SyncJoinParsingContext
}

func (encoder *RepoCmdEncoder) Init(value *RepoCmd) {
	if value.SyncJoin != nil {
		encoder.SyncJoin_encoder.Init(value.SyncJoin)
	}

	l := uint(0)
	if value.SyncJoin != nil {
		l += 3
		l += uint(enc.TLNum(encoder.SyncJoin_encoder.Length).EncodingLength())
		l += encoder.SyncJoin_encoder.Length
	}
	encoder.Length = l

}

func (context *RepoCmdParsingContext) Init() {
	context.SyncJoin_context.Init()
}

func (encoder *RepoCmdEncoder) EncodeInto(value *RepoCmd, buf []byte) {

	pos := uint(0)

	if value.SyncJoin != nil {
		buf[pos] = 253
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(400))
		pos += 3
		pos += uint(enc.TLNum(encoder.SyncJoin_encoder.Length).EncodeInto(buf[pos:]))
		if encoder.SyncJoin_encoder.Length > 0 {
			encoder.SyncJoin_encoder.EncodeInto(value.SyncJoin, buf[pos:])
			pos += encoder.SyncJoin_encoder.Length
		}
	}
}

func (encoder *RepoCmdEncoder) Encode(value *RepoCmd) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *RepoCmdParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*RepoCmd, error) {

	var handled_SyncJoin bool = false

	progress := -1
	_ = progress

	value := &RepoCmd{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 400:
				if true {
					handled = true
					handled_SyncJoin = true
					value.SyncJoin, err = context.SyncJoin_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_SyncJoin && err == nil {
		value.SyncJoin = nil
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *RepoCmd) Encode() enc.Wire {
	encoder := RepoCmdEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *RepoCmd) Bytes() []byte {
	return value.Encode().Join()
}

func ParseRepoCmd(reader enc.WireView, ignoreCritical bool) (*RepoCmd, error) {
	context := RepoCmdParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type RepoCmdResEncoder struct {
	Length uint
}

type RepoCmdResParsingContext struct {
}

func (encoder *RepoCmdResEncoder) Init(value *RepoCmdRes) {

	l := uint(0)
	l += 3
	l += uint(1 + enc.Nat(value.Status).EncodingLength())
	l += 3
	l += uint(enc.TLNum(len(value.Message)).EncodingLength())
	l += uint(len(value.Message))
	encoder.Length = l

}

func (context *RepoCmdResParsingContext) Init() {

}

func (encoder *RepoCmdResEncoder) EncodeInto(value *RepoCmdRes, buf []byte) {

	pos := uint(0)

	buf[pos] = 253
	binary.BigEndian.PutUint16(buf[pos+1:], uint16(657))
	pos += 3

	buf[pos] = byte(enc.Nat(value.Status).EncodeInto(buf[pos+1:]))
	pos += uint(1 + buf[pos])
	buf[pos] = 253
	binary.BigEndian.PutUint16(buf[pos+1:], uint16(658))
	pos += 3
	pos += uint(enc.TLNum(len(value.Message)).EncodeInto(buf[pos:]))
	copy(buf[pos:], value.Message)
	pos += uint(len(value.Message))
}

func (encoder *RepoCmdResEncoder) Encode(value *RepoCmdRes) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *RepoCmdResParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*RepoCmdRes, error) {

	var handled_Status bool = false
	var handled_Message bool = false

	progress := -1
	_ = progress

	value := &RepoCmdRes{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 657:
				if true {
					handled = true
					handled_Status = true
					value.Status = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.Status = uint64(value.Status<<8) | uint64(x)
						}
					}
				}
			case 658:
				if true {
					handled = true
					handled_Message = true
					{
						var builder strings.Builder
						_, err = reader.CopyN(&builder, int(l))
						if err == nil {
							value.Message = builder.String()
						}
					}
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Status && err == nil {
		err = enc.ErrSkipRequired{Name: "Status", TypeNum: 657}
	}
	if !handled_Message && err == nil {
		err = enc.ErrSkipRequired{Name: "Message", TypeNum: 658}
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *RepoCmdRes) Encode() enc.Wire {
	encoder := RepoCmdResEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *RepoCmdRes) Bytes() []byte {
	return value.Encode().Join()
}

func ParseRepoCmdRes(reader enc.WireView, ignoreCritical bool) (*RepoCmdRes, error) {
	context := RepoCmdResParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type SyncJoinEncoder struct {
	Length uint

	Protocol_length         uint
	Group_length            uint
	HistorySnapshot_encoder HistorySnapshotConfigEncoder
}

type SyncJoinParsingContext struct {
	HistorySnapshot_context HistorySnapshotConfigParsingContext
}

func (encoder *SyncJoinEncoder) Init(value *SyncJoin) {
	if value.Protocol != nil {
		encoder.Protocol_length = 0
		for _, c := range value.Protocol {
			encoder.Protocol_length += uint(c.EncodingLength())
		}
	}
	if value.Group != nil {
		encoder.Group_length = 0
		for _, c := range value.Group {
			encoder.Group_length += uint(c.EncodingLength())
		}
	}
	if value.HistorySnapshot != nil {
		encoder.HistorySnapshot_encoder.Init(value.HistorySnapshot)
	}

	l := uint(0)
	if value.Protocol != nil {
		l += 3
		l += uint(enc.TLNum(encoder.Protocol_length).EncodingLength())
		l += encoder.Protocol_length
	}
	if value.Group != nil {
		l += 3
		l += uint(enc.TLNum(encoder.Group_length).EncodingLength())
		l += encoder.Group_length
	}
	if value.HistorySnapshot != nil {
		l += 3
		l += uint(enc.TLNum(encoder.HistorySnapshot_encoder.Length).EncodingLength())
		l += encoder.HistorySnapshot_encoder.Length
	}
	encoder.Length = l

}

func (context *SyncJoinParsingContext) Init() {

	context.HistorySnapshot_context.Init()
}

func (encoder *SyncJoinEncoder) EncodeInto(value *SyncJoin, buf []byte) {

	pos := uint(0)

	if value.Protocol != nil {
		buf[pos] = 253
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(401))
		pos += 3
		pos += uint(enc.TLNum(encoder.Protocol_length).EncodeInto(buf[pos:]))
		for _, c := range value.Protocol {
			pos += uint(c.EncodeInto(buf[pos:]))
		}
	}
	if value.Group != nil {
		buf[pos] = 253
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(403))
		pos += 3
		pos += uint(enc.TLNum(encoder.Group_length).EncodeInto(buf[pos:]))
		for _, c := range value.Group {
			pos += uint(c.EncodeInto(buf[pos:]))
		}
	}
	if value.HistorySnapshot != nil {
		buf[pos] = 253
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(420))
		pos += 3
		pos += uint(enc.TLNum(encoder.HistorySnapshot_encoder.Length).EncodeInto(buf[pos:]))
		if encoder.HistorySnapshot_encoder.Length > 0 {
			encoder.HistorySnapshot_encoder.EncodeInto(value.HistorySnapshot, buf[pos:])
			pos += encoder.HistorySnapshot_encoder.Length
		}
	}
}

func (encoder *SyncJoinEncoder) Encode(value *SyncJoin) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *SyncJoinParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*SyncJoin, error) {

	var handled_Protocol bool = false
	var handled_Group bool = false
	var handled_HistorySnapshot bool = false

	progress := -1
	_ = progress

	value := &SyncJoin{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 401:
				if true {
					handled = true
					handled_Protocol = true
					delegate := reader.Delegate(int(l))
					value.Protocol, err = delegate.ReadName()
				}
			case 403:
				if true {
					handled = true
					handled_Group = true
					delegate := reader.Delegate(int(l))
					value.Group, err = delegate.ReadName()
				}
			case 420:
				if true {
					handled = true
					handled_HistorySnapshot = true
					value.HistorySnapshot, err = context.HistorySnapshot_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Protocol && err == nil {
		value.Protocol = nil
	}
	if !handled_Group && err == nil {
		value.Group = nil
	}
	if !handled_HistorySnapshot && err == nil {
		value.HistorySnapshot = nil
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *SyncJoin) Encode() enc.Wire {
	encoder := SyncJoinEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *SyncJoin) Bytes() []byte {
	return value.Encode().Join()
}

func ParseSyncJoin(reader enc.WireView, ignoreCritical bool) (*SyncJoin, error) {
	context := SyncJoinParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type HistorySnapshotConfigEncoder struct {
	Length uint
}

type HistorySnapshotConfigParsingContext struct {
}

func (encoder *HistorySnapshotConfigEncoder) Init(value *HistorySnapshotConfig) {

	l := uint(0)
	l += 3
	l += uint(1 + enc.Nat(value.Threshold).EncodingLength())
	encoder.Length = l

}

func (context *HistorySnapshotConfigParsingContext) Init() {

}

func (encoder *HistorySnapshotConfigEncoder) EncodeInto(value *HistorySnapshotConfig, buf []byte) {

	pos := uint(0)

	buf[pos] = 253
	binary.BigEndian.PutUint16(buf[pos+1:], uint16(421))
	pos += 3

	buf[pos] = byte(enc.Nat(value.Threshold).EncodeInto(buf[pos+1:]))
	pos += uint(1 + buf[pos])
}

func (encoder *HistorySnapshotConfigEncoder) Encode(value *HistorySnapshotConfig) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *HistorySnapshotConfigParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*HistorySnapshotConfig, error) {

	var handled_Threshold bool = false

	progress := -1
	_ = progress

	value := &HistorySnapshotConfig{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 421:
				if true {
					handled = true
					handled_Threshold = true
					value.Threshold = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.Threshold = uint64(value.Threshold<<8) | uint64(x)
						}
					}
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Threshold && err == nil {
		err = enc.ErrSkipRequired{Name: "Threshold", TypeNum: 421}
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *HistorySnapshotConfig) Encode() enc.Wire {
	encoder := HistorySnapshotConfigEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *HistorySnapshotConfig) Bytes() []byte {
	return value.Encode().Join()
}

func ParseHistorySnapshotConfig(reader enc.WireView, ignoreCritical bool) (*HistorySnapshotConfig, error) {
	context := HistorySnapshotConfigParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}
