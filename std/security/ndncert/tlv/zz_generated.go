// Code generated by ndn tlv codegen DO NOT EDIT.
package tlv

import (
	"io"
	"strings"

	enc "github.com/named-data/ndnd/std/encoding"
)

type CaProfileEncoder struct {
	length uint

	CaPrefix_encoder NameContainerEncoder

	ParamKey_subencoder []struct {
	}

	CaCert_length uint
}

type CaProfileParsingContext struct {
	CaPrefix_context NameContainerParsingContext
}

func (encoder *CaProfileEncoder) Init(value *CaProfile) {
	if value.CaPrefix != nil {
		encoder.CaPrefix_encoder.Init(value.CaPrefix)
	}

	{
		ParamKey_l := len(value.ParamKey)
		encoder.ParamKey_subencoder = make([]struct {
		}, ParamKey_l)
		for i := 0; i < ParamKey_l; i++ {
			pseudoEncoder := &encoder.ParamKey_subencoder[i]
			pseudoValue := struct {
				ParamKey string
			}{
				ParamKey: value.ParamKey[i],
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue

				_ = encoder
				_ = value
			}
		}
	}

	if value.CaCert != nil {
		encoder.CaCert_length = 0
		for _, c := range value.CaCert {
			encoder.CaCert_length += uint(len(c))
		}
	}

	l := uint(0)
	if value.CaPrefix != nil {
		l += 1
		l += uint(enc.TLNum(encoder.CaPrefix_encoder.length).EncodingLength())
		l += encoder.CaPrefix_encoder.length
	}
	l += 1
	l += uint(enc.TLNum(len(value.CaInfo)).EncodingLength())
	l += uint(len(value.CaInfo))
	if value.ParamKey != nil {
		for seq_i, seq_v := range value.ParamKey {
			pseudoEncoder := &encoder.ParamKey_subencoder[seq_i]
			pseudoValue := struct {
				ParamKey string
			}{
				ParamKey: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				l += 1
				l += uint(enc.TLNum(len(value.ParamKey)).EncodingLength())
				l += uint(len(value.ParamKey))
				_ = encoder
				_ = value
			}
		}
	}
	l += 1
	l += uint(1 + enc.Nat(value.MaxValidPeriod).EncodingLength())
	if value.CaCert != nil {
		l += 1
		l += uint(enc.TLNum(encoder.CaCert_length).EncodingLength())
		l += encoder.CaCert_length
	}
	encoder.length = l

}

func (context *CaProfileParsingContext) Init() {
	context.CaPrefix_context.Init()

}

func (encoder *CaProfileEncoder) EncodeInto(value *CaProfile, buf []byte) {

	pos := uint(0)

	if value.CaPrefix != nil {
		buf[pos] = byte(129)
		pos += 1
		pos += uint(enc.TLNum(encoder.CaPrefix_encoder.length).EncodeInto(buf[pos:]))
		if encoder.CaPrefix_encoder.length > 0 {
			encoder.CaPrefix_encoder.EncodeInto(value.CaPrefix, buf[pos:])
			pos += encoder.CaPrefix_encoder.length
		}
	}
	buf[pos] = byte(131)
	pos += 1
	pos += uint(enc.TLNum(len(value.CaInfo)).EncodeInto(buf[pos:]))
	copy(buf[pos:], value.CaInfo)
	pos += uint(len(value.CaInfo))
	if value.ParamKey != nil {
		for seq_i, seq_v := range value.ParamKey {
			pseudoEncoder := &encoder.ParamKey_subencoder[seq_i]
			pseudoValue := struct {
				ParamKey string
			}{
				ParamKey: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				buf[pos] = byte(133)
				pos += 1
				pos += uint(enc.TLNum(len(value.ParamKey)).EncodeInto(buf[pos:]))
				copy(buf[pos:], value.ParamKey)
				pos += uint(len(value.ParamKey))
				_ = encoder
				_ = value
			}
		}
	}
	buf[pos] = byte(139)
	pos += 1

	buf[pos] = byte(enc.Nat(value.MaxValidPeriod).EncodeInto(buf[pos+1:]))
	pos += uint(1 + buf[pos])
	if value.CaCert != nil {
		buf[pos] = byte(137)
		pos += 1
		pos += uint(enc.TLNum(encoder.CaCert_length).EncodeInto(buf[pos:]))
		for _, w := range value.CaCert {
			copy(buf[pos:], w)
			pos += uint(len(w))
		}
	}
}

func (encoder *CaProfileEncoder) Encode(value *CaProfile) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *CaProfileParsingContext) Parse(reader enc.FastReader, ignoreCritical bool) (*CaProfile, error) {

	var handled_CaPrefix bool = false
	var handled_CaInfo bool = false
	var handled_ParamKey bool = false
	var handled_MaxValidPeriod bool = false
	var handled_CaCert bool = false

	progress := -1
	_ = progress

	value := &CaProfile{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 129:
				if true {
					handled = true
					handled_CaPrefix = true
					value.CaPrefix, err = context.CaPrefix_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			case 131:
				if true {
					handled = true
					handled_CaInfo = true
					{
						var builder strings.Builder
						_, err = reader.CopyN(&builder, int64(l))
						if err == nil {
							value.CaInfo = builder.String()
						}
					}
				}
			case 133:
				if true {
					handled = true
					handled_ParamKey = true
					if value.ParamKey == nil {
						value.ParamKey = make([]string, 0)
					}
					{
						pseudoValue := struct {
							ParamKey string
						}{}
						{
							value := &pseudoValue
							{
								var builder strings.Builder
								_, err = reader.CopyN(&builder, int64(l))
								if err == nil {
									value.ParamKey = builder.String()
								}
							}
							_ = value
						}
						value.ParamKey = append(value.ParamKey, pseudoValue.ParamKey)
					}
					progress--
				}
			case 139:
				if true {
					handled = true
					handled_MaxValidPeriod = true
					value.MaxValidPeriod = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.MaxValidPeriod = uint64(value.MaxValidPeriod<<8) | uint64(x)
						}
					}
				}
			case 137:
				if true {
					handled = true
					handled_CaCert = true
					value.CaCert, err = reader.ReadWire(int(l))
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_CaPrefix && err == nil {
		value.CaPrefix = nil
	}
	if !handled_CaInfo && err == nil {
		err = enc.ErrSkipRequired{Name: "CaInfo", TypeNum: 131}
	}
	if !handled_ParamKey && err == nil {
		// sequence - skip
	}
	if !handled_MaxValidPeriod && err == nil {
		err = enc.ErrSkipRequired{Name: "MaxValidPeriod", TypeNum: 139}
	}
	if !handled_CaCert && err == nil {
		value.CaCert = nil
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *CaProfile) Encode() enc.Wire {
	encoder := CaProfileEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *CaProfile) Bytes() []byte {
	return value.Encode().Join()
}

func ParseCaProfile(reader enc.FastReader, ignoreCritical bool) (*CaProfile, error) {
	context := CaProfileParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type ProbeReqEncoder struct {
	length uint

	Params_valencoder map[string]*struct {
	}
}

type ProbeReqParsingContext struct {
}

func (encoder *ProbeReqEncoder) Init(value *ProbeReq) {
	{
		Params_l := len(value.Params)
		encoder.Params_valencoder = make(map[string]*struct {
		}, Params_l)
		for map_k := range value.Params {
			pseudoEncoder := &struct {
			}{}
			encoder.Params_valencoder[map_k] = pseudoEncoder
			pseudoValue := struct {
				Params_v []byte
			}{
				Params_v: value.Params[map_k],
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue

				_ = encoder
				_ = value
			}
		}
	}

	l := uint(0)
	if value.Params != nil {
		for map_k, map_v := range value.Params {
			pseudoEncoder := encoder.Params_valencoder[map_k]
			pseudoValue := struct {
				Params_k string
				Params_v []byte
			}{
				Params_k: map_k,
				Params_v: map_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				l += 1
				l += uint(enc.TLNum(len(value.Params_k)).EncodingLength())
				l += uint(len(value.Params_k))
				if value.Params_v != nil {
					l += 1
					l += uint(enc.TLNum(len(value.Params_v)).EncodingLength())
					l += uint(len(value.Params_v))
				}
				_ = encoder
				_ = value
			}
		}
	}
	encoder.length = l

}

func (context *ProbeReqParsingContext) Init() {

}

func (encoder *ProbeReqEncoder) EncodeInto(value *ProbeReq, buf []byte) {

	pos := uint(0)

	if value.Params != nil {
		for map_k, map_v := range value.Params {
			pseudoEncoder := encoder.Params_valencoder[map_k]
			pseudoValue := struct {
				Params_k string
				Params_v []byte
			}{
				Params_k: map_k,
				Params_v: map_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				buf[pos] = byte(133)
				pos += 1
				pos += uint(enc.TLNum(len(value.Params_k)).EncodeInto(buf[pos:]))
				copy(buf[pos:], value.Params_k)
				pos += uint(len(value.Params_k))
				if value.Params_v != nil {
					buf[pos] = byte(135)
					pos += 1
					pos += uint(enc.TLNum(len(value.Params_v)).EncodeInto(buf[pos:]))
					copy(buf[pos:], value.Params_v)
					pos += uint(len(value.Params_v))
				}
				_ = encoder
				_ = value
			}
		}
	}
}

func (encoder *ProbeReqEncoder) Encode(value *ProbeReq) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *ProbeReqParsingContext) Parse(reader enc.FastReader, ignoreCritical bool) (*ProbeReq, error) {

	var handled_Params bool = false

	progress := -1
	_ = progress

	value := &ProbeReq{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 133:
				if true {
					handled = true
					handled_Params = true
					if value.Params == nil {
						value.Params = make(map[string][]byte)
					}
					{
						pseudoValue := struct {
							Params_k string
							Params_v []byte
						}{}
						{
							value := &pseudoValue
							{
								var builder strings.Builder
								_, err = reader.CopyN(&builder, int64(l))
								if err == nil {
									value.Params_k = builder.String()
								}
							}
							typ := enc.TLNum(0)
							l := enc.TLNum(0)
							typ, err = reader.ReadTLNum()
							if err != nil {
								return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
							}
							l, err = reader.ReadTLNum()
							if err != nil {
								return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
							}
							if typ != 135 {
								return nil, enc.ErrFailToParse{TypeNum: 133, Err: enc.ErrUnrecognizedField{TypeNum: typ}}
							}
							value.Params_v = make([]byte, l)
							_, err = reader.ReadFull(value.Params_v)
							_ = value
						}
						value.Params[pseudoValue.Params_k] = pseudoValue.Params_v
					}
					progress--
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Params && err == nil {
		// map - skip
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *ProbeReq) Encode() enc.Wire {
	encoder := ProbeReqEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *ProbeReq) Bytes() []byte {
	return value.Encode().Join()
}

func ParseProbeReq(reader enc.FastReader, ignoreCritical bool) (*ProbeReq, error) {
	context := ProbeReqParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type ProbeResValsEncoder struct {
	length uint

	Response_length uint
}

type ProbeResValsParsingContext struct {
}

func (encoder *ProbeResValsEncoder) Init(value *ProbeResVals) {
	if value.Response != nil {
		encoder.Response_length = 0
		for _, c := range value.Response {
			encoder.Response_length += uint(c.EncodingLength())
		}
	}

	l := uint(0)
	if value.Response != nil {
		l += 1
		l += uint(enc.TLNum(encoder.Response_length).EncodingLength())
		l += encoder.Response_length
	}
	if optval, ok := value.MaxSuffixLength.Get(); ok {
		l += 1
		l += uint(1 + enc.Nat(optval).EncodingLength())
	}
	encoder.length = l

}

func (context *ProbeResValsParsingContext) Init() {

}

func (encoder *ProbeResValsEncoder) EncodeInto(value *ProbeResVals, buf []byte) {

	pos := uint(0)

	if value.Response != nil {
		buf[pos] = byte(7)
		pos += 1
		pos += uint(enc.TLNum(encoder.Response_length).EncodeInto(buf[pos:]))
		for _, c := range value.Response {
			pos += uint(c.EncodeInto(buf[pos:]))
		}
	}
	if optval, ok := value.MaxSuffixLength.Get(); ok {
		buf[pos] = byte(143)
		pos += 1

		buf[pos] = byte(enc.Nat(optval).EncodeInto(buf[pos+1:]))
		pos += uint(1 + buf[pos])

	}
}

func (encoder *ProbeResValsEncoder) Encode(value *ProbeResVals) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *ProbeResValsParsingContext) Parse(reader enc.FastReader, ignoreCritical bool) (*ProbeResVals, error) {

	var handled_Response bool = false
	var handled_MaxSuffixLength bool = false

	progress := -1
	_ = progress

	value := &ProbeResVals{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 7:
				if true {
					handled = true
					handled_Response = true
					delegate := reader.Delegate(int(l))
					value.Response, err = delegate.ReadName()
				}
			case 143:
				if true {
					handled = true
					handled_MaxSuffixLength = true
					{
						optval := uint64(0)
						optval = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								optval = uint64(optval<<8) | uint64(x)
							}
						}
						value.MaxSuffixLength.Set(optval)
					}
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Response && err == nil {
		value.Response = nil
	}
	if !handled_MaxSuffixLength && err == nil {
		value.MaxSuffixLength.Unset()
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *ProbeResVals) Encode() enc.Wire {
	encoder := ProbeResValsEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *ProbeResVals) Bytes() []byte {
	return value.Encode().Join()
}

func ParseProbeResVals(reader enc.FastReader, ignoreCritical bool) (*ProbeResVals, error) {
	context := ProbeResValsParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type ProbeResEncoder struct {
	length uint

	Vals_subencoder []struct {
		Vals_encoder ProbeResValsEncoder
	}
	RedirectPrefix_encoder NameContainerEncoder
}

type ProbeResParsingContext struct {
	Vals_context           ProbeResValsParsingContext
	RedirectPrefix_context NameContainerParsingContext
}

func (encoder *ProbeResEncoder) Init(value *ProbeRes) {
	{
		Vals_l := len(value.Vals)
		encoder.Vals_subencoder = make([]struct {
			Vals_encoder ProbeResValsEncoder
		}, Vals_l)
		for i := 0; i < Vals_l; i++ {
			pseudoEncoder := &encoder.Vals_subencoder[i]
			pseudoValue := struct {
				Vals *ProbeResVals
			}{
				Vals: value.Vals[i],
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Vals != nil {
					encoder.Vals_encoder.Init(value.Vals)
				}
				_ = encoder
				_ = value
			}
		}
	}
	if value.RedirectPrefix != nil {
		encoder.RedirectPrefix_encoder.Init(value.RedirectPrefix)
	}

	l := uint(0)
	if value.Vals != nil {
		for seq_i, seq_v := range value.Vals {
			pseudoEncoder := &encoder.Vals_subencoder[seq_i]
			pseudoValue := struct {
				Vals *ProbeResVals
			}{
				Vals: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Vals != nil {
					l += 1
					l += uint(enc.TLNum(encoder.Vals_encoder.length).EncodingLength())
					l += encoder.Vals_encoder.length
				}
				_ = encoder
				_ = value
			}
		}
	}
	if value.RedirectPrefix != nil {
		l += 1
		l += uint(enc.TLNum(encoder.RedirectPrefix_encoder.length).EncodingLength())
		l += encoder.RedirectPrefix_encoder.length
	}
	encoder.length = l

}

func (context *ProbeResParsingContext) Init() {
	context.Vals_context.Init()
	context.RedirectPrefix_context.Init()
}

func (encoder *ProbeResEncoder) EncodeInto(value *ProbeRes, buf []byte) {

	pos := uint(0)

	if value.Vals != nil {
		for seq_i, seq_v := range value.Vals {
			pseudoEncoder := &encoder.Vals_subencoder[seq_i]
			pseudoValue := struct {
				Vals *ProbeResVals
			}{
				Vals: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Vals != nil {
					buf[pos] = byte(141)
					pos += 1
					pos += uint(enc.TLNum(encoder.Vals_encoder.length).EncodeInto(buf[pos:]))
					if encoder.Vals_encoder.length > 0 {
						encoder.Vals_encoder.EncodeInto(value.Vals, buf[pos:])
						pos += encoder.Vals_encoder.length
					}
				}
				_ = encoder
				_ = value
			}
		}
	}
	if value.RedirectPrefix != nil {
		buf[pos] = byte(179)
		pos += 1
		pos += uint(enc.TLNum(encoder.RedirectPrefix_encoder.length).EncodeInto(buf[pos:]))
		if encoder.RedirectPrefix_encoder.length > 0 {
			encoder.RedirectPrefix_encoder.EncodeInto(value.RedirectPrefix, buf[pos:])
			pos += encoder.RedirectPrefix_encoder.length
		}
	}
}

func (encoder *ProbeResEncoder) Encode(value *ProbeRes) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *ProbeResParsingContext) Parse(reader enc.FastReader, ignoreCritical bool) (*ProbeRes, error) {

	var handled_Vals bool = false
	var handled_RedirectPrefix bool = false

	progress := -1
	_ = progress

	value := &ProbeRes{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 141:
				if true {
					handled = true
					handled_Vals = true
					if value.Vals == nil {
						value.Vals = make([]*ProbeResVals, 0)
					}
					{
						pseudoValue := struct {
							Vals *ProbeResVals
						}{}
						{
							value := &pseudoValue
							value.Vals, err = context.Vals_context.Parse(reader.Delegate(int(l)), ignoreCritical)
							_ = value
						}
						value.Vals = append(value.Vals, pseudoValue.Vals)
					}
					progress--
				}
			case 179:
				if true {
					handled = true
					handled_RedirectPrefix = true
					value.RedirectPrefix, err = context.RedirectPrefix_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Vals && err == nil {
		// sequence - skip
	}
	if !handled_RedirectPrefix && err == nil {
		value.RedirectPrefix = nil
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *ProbeRes) Encode() enc.Wire {
	encoder := ProbeResEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *ProbeRes) Bytes() []byte {
	return value.Encode().Join()
}

func ParseProbeRes(reader enc.FastReader, ignoreCritical bool) (*ProbeRes, error) {
	context := ProbeResParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type NewReqEncoder struct {
	length uint

	CertReq_length uint
}

type NewReqParsingContext struct {
}

func (encoder *NewReqEncoder) Init(value *NewReq) {

	if value.CertReq != nil {
		encoder.CertReq_length = 0
		for _, c := range value.CertReq {
			encoder.CertReq_length += uint(len(c))
		}
	}

	l := uint(0)
	if value.EcdhPub != nil {
		l += 1
		l += uint(enc.TLNum(len(value.EcdhPub)).EncodingLength())
		l += uint(len(value.EcdhPub))
	}
	if value.CertReq != nil {
		l += 1
		l += uint(enc.TLNum(encoder.CertReq_length).EncodingLength())
		l += encoder.CertReq_length
	}
	encoder.length = l

}

func (context *NewReqParsingContext) Init() {

}

func (encoder *NewReqEncoder) EncodeInto(value *NewReq, buf []byte) {

	pos := uint(0)

	if value.EcdhPub != nil {
		buf[pos] = byte(145)
		pos += 1
		pos += uint(enc.TLNum(len(value.EcdhPub)).EncodeInto(buf[pos:]))
		copy(buf[pos:], value.EcdhPub)
		pos += uint(len(value.EcdhPub))
	}
	if value.CertReq != nil {
		buf[pos] = byte(147)
		pos += 1
		pos += uint(enc.TLNum(encoder.CertReq_length).EncodeInto(buf[pos:]))
		for _, w := range value.CertReq {
			copy(buf[pos:], w)
			pos += uint(len(w))
		}
	}
}

func (encoder *NewReqEncoder) Encode(value *NewReq) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *NewReqParsingContext) Parse(reader enc.FastReader, ignoreCritical bool) (*NewReq, error) {

	var handled_EcdhPub bool = false
	var handled_CertReq bool = false

	progress := -1
	_ = progress

	value := &NewReq{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 145:
				if true {
					handled = true
					handled_EcdhPub = true
					value.EcdhPub = make([]byte, l)
					_, err = reader.ReadFull(value.EcdhPub)
				}
			case 147:
				if true {
					handled = true
					handled_CertReq = true
					value.CertReq, err = reader.ReadWire(int(l))
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_EcdhPub && err == nil {
		value.EcdhPub = nil
	}
	if !handled_CertReq && err == nil {
		value.CertReq = nil
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *NewReq) Encode() enc.Wire {
	encoder := NewReqEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *NewReq) Bytes() []byte {
	return value.Encode().Join()
}

func ParseNewReq(reader enc.FastReader, ignoreCritical bool) (*NewReq, error) {
	context := NewReqParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type NewResEncoder struct {
	length uint

	Challenge_subencoder []struct {
	}
}

type NewResParsingContext struct {
}

func (encoder *NewResEncoder) Init(value *NewRes) {

	{
		Challenge_l := len(value.Challenge)
		encoder.Challenge_subencoder = make([]struct {
		}, Challenge_l)
		for i := 0; i < Challenge_l; i++ {
			pseudoEncoder := &encoder.Challenge_subencoder[i]
			pseudoValue := struct {
				Challenge string
			}{
				Challenge: value.Challenge[i],
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue

				_ = encoder
				_ = value
			}
		}
	}

	l := uint(0)
	if value.EcdhPub != nil {
		l += 1
		l += uint(enc.TLNum(len(value.EcdhPub)).EncodingLength())
		l += uint(len(value.EcdhPub))
	}
	if value.Salt != nil {
		l += 1
		l += uint(enc.TLNum(len(value.Salt)).EncodingLength())
		l += uint(len(value.Salt))
	}
	if value.ReqId != nil {
		l += 1
		l += uint(enc.TLNum(len(value.ReqId)).EncodingLength())
		l += uint(len(value.ReqId))
	}
	if value.Challenge != nil {
		for seq_i, seq_v := range value.Challenge {
			pseudoEncoder := &encoder.Challenge_subencoder[seq_i]
			pseudoValue := struct {
				Challenge string
			}{
				Challenge: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				l += 1
				l += uint(enc.TLNum(len(value.Challenge)).EncodingLength())
				l += uint(len(value.Challenge))
				_ = encoder
				_ = value
			}
		}
	}
	encoder.length = l

}

func (context *NewResParsingContext) Init() {

}

func (encoder *NewResEncoder) EncodeInto(value *NewRes, buf []byte) {

	pos := uint(0)

	if value.EcdhPub != nil {
		buf[pos] = byte(145)
		pos += 1
		pos += uint(enc.TLNum(len(value.EcdhPub)).EncodeInto(buf[pos:]))
		copy(buf[pos:], value.EcdhPub)
		pos += uint(len(value.EcdhPub))
	}
	if value.Salt != nil {
		buf[pos] = byte(149)
		pos += 1
		pos += uint(enc.TLNum(len(value.Salt)).EncodeInto(buf[pos:]))
		copy(buf[pos:], value.Salt)
		pos += uint(len(value.Salt))
	}
	if value.ReqId != nil {
		buf[pos] = byte(151)
		pos += 1
		pos += uint(enc.TLNum(len(value.ReqId)).EncodeInto(buf[pos:]))
		copy(buf[pos:], value.ReqId)
		pos += uint(len(value.ReqId))
	}
	if value.Challenge != nil {
		for seq_i, seq_v := range value.Challenge {
			pseudoEncoder := &encoder.Challenge_subencoder[seq_i]
			pseudoValue := struct {
				Challenge string
			}{
				Challenge: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				buf[pos] = byte(153)
				pos += 1
				pos += uint(enc.TLNum(len(value.Challenge)).EncodeInto(buf[pos:]))
				copy(buf[pos:], value.Challenge)
				pos += uint(len(value.Challenge))
				_ = encoder
				_ = value
			}
		}
	}
}

func (encoder *NewResEncoder) Encode(value *NewRes) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *NewResParsingContext) Parse(reader enc.FastReader, ignoreCritical bool) (*NewRes, error) {

	var handled_EcdhPub bool = false
	var handled_Salt bool = false
	var handled_ReqId bool = false
	var handled_Challenge bool = false

	progress := -1
	_ = progress

	value := &NewRes{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 145:
				if true {
					handled = true
					handled_EcdhPub = true
					value.EcdhPub = make([]byte, l)
					_, err = reader.ReadFull(value.EcdhPub)
				}
			case 149:
				if true {
					handled = true
					handled_Salt = true
					value.Salt = make([]byte, l)
					_, err = reader.ReadFull(value.Salt)
				}
			case 151:
				if true {
					handled = true
					handled_ReqId = true
					value.ReqId = make([]byte, l)
					_, err = reader.ReadFull(value.ReqId)
				}
			case 153:
				if true {
					handled = true
					handled_Challenge = true
					if value.Challenge == nil {
						value.Challenge = make([]string, 0)
					}
					{
						pseudoValue := struct {
							Challenge string
						}{}
						{
							value := &pseudoValue
							{
								var builder strings.Builder
								_, err = reader.CopyN(&builder, int64(l))
								if err == nil {
									value.Challenge = builder.String()
								}
							}
							_ = value
						}
						value.Challenge = append(value.Challenge, pseudoValue.Challenge)
					}
					progress--
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_EcdhPub && err == nil {
		value.EcdhPub = nil
	}
	if !handled_Salt && err == nil {
		value.Salt = nil
	}
	if !handled_ReqId && err == nil {
		value.ReqId = nil
	}
	if !handled_Challenge && err == nil {
		// sequence - skip
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *NewRes) Encode() enc.Wire {
	encoder := NewResEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *NewRes) Bytes() []byte {
	return value.Encode().Join()
}

func ParseNewRes(reader enc.FastReader, ignoreCritical bool) (*NewRes, error) {
	context := NewResParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type CipherMsgEncoder struct {
	length uint
}

type CipherMsgParsingContext struct {
}

func (encoder *CipherMsgEncoder) Init(value *CipherMsg) {

	l := uint(0)
	if value.InitVec != nil {
		l += 1
		l += uint(enc.TLNum(len(value.InitVec)).EncodingLength())
		l += uint(len(value.InitVec))
	}
	if value.AuthNTag != nil {
		l += 1
		l += uint(enc.TLNum(len(value.AuthNTag)).EncodingLength())
		l += uint(len(value.AuthNTag))
	}
	if value.Payload != nil {
		l += 1
		l += uint(enc.TLNum(len(value.Payload)).EncodingLength())
		l += uint(len(value.Payload))
	}
	encoder.length = l

}

func (context *CipherMsgParsingContext) Init() {

}

func (encoder *CipherMsgEncoder) EncodeInto(value *CipherMsg, buf []byte) {

	pos := uint(0)

	if value.InitVec != nil {
		buf[pos] = byte(157)
		pos += 1
		pos += uint(enc.TLNum(len(value.InitVec)).EncodeInto(buf[pos:]))
		copy(buf[pos:], value.InitVec)
		pos += uint(len(value.InitVec))
	}
	if value.AuthNTag != nil {
		buf[pos] = byte(175)
		pos += 1
		pos += uint(enc.TLNum(len(value.AuthNTag)).EncodeInto(buf[pos:]))
		copy(buf[pos:], value.AuthNTag)
		pos += uint(len(value.AuthNTag))
	}
	if value.Payload != nil {
		buf[pos] = byte(159)
		pos += 1
		pos += uint(enc.TLNum(len(value.Payload)).EncodeInto(buf[pos:]))
		copy(buf[pos:], value.Payload)
		pos += uint(len(value.Payload))
	}
}

func (encoder *CipherMsgEncoder) Encode(value *CipherMsg) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *CipherMsgParsingContext) Parse(reader enc.FastReader, ignoreCritical bool) (*CipherMsg, error) {

	var handled_InitVec bool = false
	var handled_AuthNTag bool = false
	var handled_Payload bool = false

	progress := -1
	_ = progress

	value := &CipherMsg{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 157:
				if true {
					handled = true
					handled_InitVec = true
					value.InitVec = make([]byte, l)
					_, err = reader.ReadFull(value.InitVec)
				}
			case 175:
				if true {
					handled = true
					handled_AuthNTag = true
					value.AuthNTag = make([]byte, l)
					_, err = reader.ReadFull(value.AuthNTag)
				}
			case 159:
				if true {
					handled = true
					handled_Payload = true
					value.Payload = make([]byte, l)
					_, err = reader.ReadFull(value.Payload)
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_InitVec && err == nil {
		value.InitVec = nil
	}
	if !handled_AuthNTag && err == nil {
		value.AuthNTag = nil
	}
	if !handled_Payload && err == nil {
		value.Payload = nil
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *CipherMsg) Encode() enc.Wire {
	encoder := CipherMsgEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *CipherMsg) Bytes() []byte {
	return value.Encode().Join()
}

func ParseCipherMsg(reader enc.FastReader, ignoreCritical bool) (*CipherMsg, error) {
	context := CipherMsgParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type ChallengeReqEncoder struct {
	length uint

	Params_valencoder map[string]*struct {
	}
}

type ChallengeReqParsingContext struct {
}

func (encoder *ChallengeReqEncoder) Init(value *ChallengeReq) {

	{
		Params_l := len(value.Params)
		encoder.Params_valencoder = make(map[string]*struct {
		}, Params_l)
		for map_k := range value.Params {
			pseudoEncoder := &struct {
			}{}
			encoder.Params_valencoder[map_k] = pseudoEncoder
			pseudoValue := struct {
				Params_v []byte
			}{
				Params_v: value.Params[map_k],
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue

				_ = encoder
				_ = value
			}
		}
	}

	l := uint(0)
	l += 1
	l += uint(enc.TLNum(len(value.Challenge)).EncodingLength())
	l += uint(len(value.Challenge))
	if value.Params != nil {
		for map_k, map_v := range value.Params {
			pseudoEncoder := encoder.Params_valencoder[map_k]
			pseudoValue := struct {
				Params_k string
				Params_v []byte
			}{
				Params_k: map_k,
				Params_v: map_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				l += 1
				l += uint(enc.TLNum(len(value.Params_k)).EncodingLength())
				l += uint(len(value.Params_k))
				if value.Params_v != nil {
					l += 1
					l += uint(enc.TLNum(len(value.Params_v)).EncodingLength())
					l += uint(len(value.Params_v))
				}
				_ = encoder
				_ = value
			}
		}
	}
	encoder.length = l

}

func (context *ChallengeReqParsingContext) Init() {

}

func (encoder *ChallengeReqEncoder) EncodeInto(value *ChallengeReq, buf []byte) {

	pos := uint(0)

	buf[pos] = byte(161)
	pos += 1
	pos += uint(enc.TLNum(len(value.Challenge)).EncodeInto(buf[pos:]))
	copy(buf[pos:], value.Challenge)
	pos += uint(len(value.Challenge))
	if value.Params != nil {
		for map_k, map_v := range value.Params {
			pseudoEncoder := encoder.Params_valencoder[map_k]
			pseudoValue := struct {
				Params_k string
				Params_v []byte
			}{
				Params_k: map_k,
				Params_v: map_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				buf[pos] = byte(133)
				pos += 1
				pos += uint(enc.TLNum(len(value.Params_k)).EncodeInto(buf[pos:]))
				copy(buf[pos:], value.Params_k)
				pos += uint(len(value.Params_k))
				if value.Params_v != nil {
					buf[pos] = byte(135)
					pos += 1
					pos += uint(enc.TLNum(len(value.Params_v)).EncodeInto(buf[pos:]))
					copy(buf[pos:], value.Params_v)
					pos += uint(len(value.Params_v))
				}
				_ = encoder
				_ = value
			}
		}
	}
}

func (encoder *ChallengeReqEncoder) Encode(value *ChallengeReq) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *ChallengeReqParsingContext) Parse(reader enc.FastReader, ignoreCritical bool) (*ChallengeReq, error) {

	var handled_Challenge bool = false
	var handled_Params bool = false

	progress := -1
	_ = progress

	value := &ChallengeReq{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 161:
				if true {
					handled = true
					handled_Challenge = true
					{
						var builder strings.Builder
						_, err = reader.CopyN(&builder, int64(l))
						if err == nil {
							value.Challenge = builder.String()
						}
					}
				}
			case 133:
				if true {
					handled = true
					handled_Params = true
					if value.Params == nil {
						value.Params = make(map[string][]byte)
					}
					{
						pseudoValue := struct {
							Params_k string
							Params_v []byte
						}{}
						{
							value := &pseudoValue
							{
								var builder strings.Builder
								_, err = reader.CopyN(&builder, int64(l))
								if err == nil {
									value.Params_k = builder.String()
								}
							}
							typ := enc.TLNum(0)
							l := enc.TLNum(0)
							typ, err = reader.ReadTLNum()
							if err != nil {
								return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
							}
							l, err = reader.ReadTLNum()
							if err != nil {
								return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
							}
							if typ != 135 {
								return nil, enc.ErrFailToParse{TypeNum: 133, Err: enc.ErrUnrecognizedField{TypeNum: typ}}
							}
							value.Params_v = make([]byte, l)
							_, err = reader.ReadFull(value.Params_v)
							_ = value
						}
						value.Params[pseudoValue.Params_k] = pseudoValue.Params_v
					}
					progress--
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Challenge && err == nil {
		err = enc.ErrSkipRequired{Name: "Challenge", TypeNum: 161}
	}
	if !handled_Params && err == nil {
		// map - skip
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *ChallengeReq) Encode() enc.Wire {
	encoder := ChallengeReqEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *ChallengeReq) Bytes() []byte {
	return value.Encode().Join()
}

func ParseChallengeReq(reader enc.FastReader, ignoreCritical bool) (*ChallengeReq, error) {
	context := ChallengeReqParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type ChallengeResEncoder struct {
	length uint

	CertName_encoder       NameContainerEncoder
	ForwardingHint_encoder NameContainerEncoder
	Params_valencoder      map[string]*struct {
	}
}

type ChallengeResParsingContext struct {
	CertName_context       NameContainerParsingContext
	ForwardingHint_context NameContainerParsingContext
}

func (encoder *ChallengeResEncoder) Init(value *ChallengeRes) {

	if value.CertName != nil {
		encoder.CertName_encoder.Init(value.CertName)
	}
	if value.ForwardingHint != nil {
		encoder.ForwardingHint_encoder.Init(value.ForwardingHint)
	}
	{
		Params_l := len(value.Params)
		encoder.Params_valencoder = make(map[string]*struct {
		}, Params_l)
		for map_k := range value.Params {
			pseudoEncoder := &struct {
			}{}
			encoder.Params_valencoder[map_k] = pseudoEncoder
			pseudoValue := struct {
				Params_v []byte
			}{
				Params_v: value.Params[map_k],
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue

				_ = encoder
				_ = value
			}
		}
	}

	l := uint(0)
	l += 1
	l += uint(1 + enc.Nat(value.Status).EncodingLength())
	if value.ChalStatus != nil {
		l += 1
		l += uint(enc.TLNum(len(*value.ChalStatus)).EncodingLength())
		l += uint(len(*value.ChalStatus))
	}
	if optval, ok := value.RemainTries.Get(); ok {
		l += 1
		l += uint(1 + enc.Nat(optval).EncodingLength())
	}
	if optval, ok := value.RemainTime.Get(); ok {
		l += 1
		l += uint(1 + enc.Nat(optval).EncodingLength())
	}
	if value.CertName != nil {
		l += 1
		l += uint(enc.TLNum(encoder.CertName_encoder.length).EncodingLength())
		l += encoder.CertName_encoder.length
	}
	if value.ForwardingHint != nil {
		l += 1
		l += uint(enc.TLNum(encoder.ForwardingHint_encoder.length).EncodingLength())
		l += encoder.ForwardingHint_encoder.length
	}
	if value.Params != nil {
		for map_k, map_v := range value.Params {
			pseudoEncoder := encoder.Params_valencoder[map_k]
			pseudoValue := struct {
				Params_k string
				Params_v []byte
			}{
				Params_k: map_k,
				Params_v: map_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				l += 1
				l += uint(enc.TLNum(len(value.Params_k)).EncodingLength())
				l += uint(len(value.Params_k))
				if value.Params_v != nil {
					l += 1
					l += uint(enc.TLNum(len(value.Params_v)).EncodingLength())
					l += uint(len(value.Params_v))
				}
				_ = encoder
				_ = value
			}
		}
	}
	encoder.length = l

}

func (context *ChallengeResParsingContext) Init() {

	context.CertName_context.Init()
	context.ForwardingHint_context.Init()

}

func (encoder *ChallengeResEncoder) EncodeInto(value *ChallengeRes, buf []byte) {

	pos := uint(0)

	buf[pos] = byte(155)
	pos += 1

	buf[pos] = byte(enc.Nat(value.Status).EncodeInto(buf[pos+1:]))
	pos += uint(1 + buf[pos])
	if value.ChalStatus != nil {
		buf[pos] = byte(163)
		pos += 1
		pos += uint(enc.TLNum(len(*value.ChalStatus)).EncodeInto(buf[pos:]))
		copy(buf[pos:], *value.ChalStatus)
		pos += uint(len(*value.ChalStatus))
	}
	if optval, ok := value.RemainTries.Get(); ok {
		buf[pos] = byte(165)
		pos += 1

		buf[pos] = byte(enc.Nat(optval).EncodeInto(buf[pos+1:]))
		pos += uint(1 + buf[pos])

	}
	if optval, ok := value.RemainTime.Get(); ok {
		buf[pos] = byte(167)
		pos += 1

		buf[pos] = byte(enc.Nat(optval).EncodeInto(buf[pos+1:]))
		pos += uint(1 + buf[pos])

	}
	if value.CertName != nil {
		buf[pos] = byte(169)
		pos += 1
		pos += uint(enc.TLNum(encoder.CertName_encoder.length).EncodeInto(buf[pos:]))
		if encoder.CertName_encoder.length > 0 {
			encoder.CertName_encoder.EncodeInto(value.CertName, buf[pos:])
			pos += encoder.CertName_encoder.length
		}
	}
	if value.ForwardingHint != nil {
		buf[pos] = byte(30)
		pos += 1
		pos += uint(enc.TLNum(encoder.ForwardingHint_encoder.length).EncodeInto(buf[pos:]))
		if encoder.ForwardingHint_encoder.length > 0 {
			encoder.ForwardingHint_encoder.EncodeInto(value.ForwardingHint, buf[pos:])
			pos += encoder.ForwardingHint_encoder.length
		}
	}
	if value.Params != nil {
		for map_k, map_v := range value.Params {
			pseudoEncoder := encoder.Params_valencoder[map_k]
			pseudoValue := struct {
				Params_k string
				Params_v []byte
			}{
				Params_k: map_k,
				Params_v: map_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				buf[pos] = byte(133)
				pos += 1
				pos += uint(enc.TLNum(len(value.Params_k)).EncodeInto(buf[pos:]))
				copy(buf[pos:], value.Params_k)
				pos += uint(len(value.Params_k))
				if value.Params_v != nil {
					buf[pos] = byte(135)
					pos += 1
					pos += uint(enc.TLNum(len(value.Params_v)).EncodeInto(buf[pos:]))
					copy(buf[pos:], value.Params_v)
					pos += uint(len(value.Params_v))
				}
				_ = encoder
				_ = value
			}
		}
	}
}

func (encoder *ChallengeResEncoder) Encode(value *ChallengeRes) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *ChallengeResParsingContext) Parse(reader enc.FastReader, ignoreCritical bool) (*ChallengeRes, error) {

	var handled_Status bool = false
	var handled_ChalStatus bool = false
	var handled_RemainTries bool = false
	var handled_RemainTime bool = false
	var handled_CertName bool = false
	var handled_ForwardingHint bool = false
	var handled_Params bool = false

	progress := -1
	_ = progress

	value := &ChallengeRes{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 155:
				if true {
					handled = true
					handled_Status = true
					value.Status = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.Status = uint64(value.Status<<8) | uint64(x)
						}
					}
				}
			case 163:
				if true {
					handled = true
					handled_ChalStatus = true
					{
						var builder strings.Builder
						_, err = reader.CopyN(&builder, int64(l))
						if err == nil {
							tempStr := builder.String()
							value.ChalStatus = &tempStr
						}
					}
				}
			case 165:
				if true {
					handled = true
					handled_RemainTries = true
					{
						optval := uint64(0)
						optval = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								optval = uint64(optval<<8) | uint64(x)
							}
						}
						value.RemainTries.Set(optval)
					}
				}
			case 167:
				if true {
					handled = true
					handled_RemainTime = true
					{
						optval := uint64(0)
						optval = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								optval = uint64(optval<<8) | uint64(x)
							}
						}
						value.RemainTime.Set(optval)
					}
				}
			case 169:
				if true {
					handled = true
					handled_CertName = true
					value.CertName, err = context.CertName_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			case 30:
				if true {
					handled = true
					handled_ForwardingHint = true
					value.ForwardingHint, err = context.ForwardingHint_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			case 133:
				if true {
					handled = true
					handled_Params = true
					if value.Params == nil {
						value.Params = make(map[string][]byte)
					}
					{
						pseudoValue := struct {
							Params_k string
							Params_v []byte
						}{}
						{
							value := &pseudoValue
							{
								var builder strings.Builder
								_, err = reader.CopyN(&builder, int64(l))
								if err == nil {
									value.Params_k = builder.String()
								}
							}
							typ := enc.TLNum(0)
							l := enc.TLNum(0)
							typ, err = reader.ReadTLNum()
							if err != nil {
								return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
							}
							l, err = reader.ReadTLNum()
							if err != nil {
								return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
							}
							if typ != 135 {
								return nil, enc.ErrFailToParse{TypeNum: 133, Err: enc.ErrUnrecognizedField{TypeNum: typ}}
							}
							value.Params_v = make([]byte, l)
							_, err = reader.ReadFull(value.Params_v)
							_ = value
						}
						value.Params[pseudoValue.Params_k] = pseudoValue.Params_v
					}
					progress--
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Status && err == nil {
		err = enc.ErrSkipRequired{Name: "Status", TypeNum: 155}
	}
	if !handled_ChalStatus && err == nil {
		value.ChalStatus = nil
	}
	if !handled_RemainTries && err == nil {
		value.RemainTries.Unset()
	}
	if !handled_RemainTime && err == nil {
		value.RemainTime.Unset()
	}
	if !handled_CertName && err == nil {
		value.CertName = nil
	}
	if !handled_ForwardingHint && err == nil {
		value.ForwardingHint = nil
	}
	if !handled_Params && err == nil {
		// map - skip
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *ChallengeRes) Encode() enc.Wire {
	encoder := ChallengeResEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *ChallengeRes) Bytes() []byte {
	return value.Encode().Join()
}

func ParseChallengeRes(reader enc.FastReader, ignoreCritical bool) (*ChallengeRes, error) {
	context := ChallengeResParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type ErrorResEncoder struct {
	length uint
}

type ErrorResParsingContext struct {
}

func (encoder *ErrorResEncoder) Init(value *ErrorRes) {

	l := uint(0)
	l += 1
	l += uint(1 + enc.Nat(value.ErrCode).EncodingLength())
	l += 1
	l += uint(enc.TLNum(len(value.ErrInfo)).EncodingLength())
	l += uint(len(value.ErrInfo))
	encoder.length = l

}

func (context *ErrorResParsingContext) Init() {

}

func (encoder *ErrorResEncoder) EncodeInto(value *ErrorRes, buf []byte) {

	pos := uint(0)

	buf[pos] = byte(171)
	pos += 1

	buf[pos] = byte(enc.Nat(value.ErrCode).EncodeInto(buf[pos+1:]))
	pos += uint(1 + buf[pos])
	buf[pos] = byte(173)
	pos += 1
	pos += uint(enc.TLNum(len(value.ErrInfo)).EncodeInto(buf[pos:]))
	copy(buf[pos:], value.ErrInfo)
	pos += uint(len(value.ErrInfo))
}

func (encoder *ErrorResEncoder) Encode(value *ErrorRes) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *ErrorResParsingContext) Parse(reader enc.FastReader, ignoreCritical bool) (*ErrorRes, error) {

	var handled_ErrCode bool = false
	var handled_ErrInfo bool = false

	progress := -1
	_ = progress

	value := &ErrorRes{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 171:
				if true {
					handled = true
					handled_ErrCode = true
					value.ErrCode = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.ErrCode = uint64(value.ErrCode<<8) | uint64(x)
						}
					}
				}
			case 173:
				if true {
					handled = true
					handled_ErrInfo = true
					{
						var builder strings.Builder
						_, err = reader.CopyN(&builder, int64(l))
						if err == nil {
							value.ErrInfo = builder.String()
						}
					}
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_ErrCode && err == nil {
		err = enc.ErrSkipRequired{Name: "ErrCode", TypeNum: 171}
	}
	if !handled_ErrInfo && err == nil {
		err = enc.ErrSkipRequired{Name: "ErrInfo", TypeNum: 173}
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *ErrorRes) Encode() enc.Wire {
	encoder := ErrorResEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *ErrorRes) Bytes() []byte {
	return value.Encode().Join()
}

func ParseErrorRes(reader enc.FastReader, ignoreCritical bool) (*ErrorRes, error) {
	context := ErrorResParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type NameContainerEncoder struct {
	length uint

	Name_length uint
}

type NameContainerParsingContext struct {
}

func (encoder *NameContainerEncoder) Init(value *NameContainer) {
	if value.Name != nil {
		encoder.Name_length = 0
		for _, c := range value.Name {
			encoder.Name_length += uint(c.EncodingLength())
		}
	}

	l := uint(0)
	if value.Name != nil {
		l += 1
		l += uint(enc.TLNum(encoder.Name_length).EncodingLength())
		l += encoder.Name_length
	}
	encoder.length = l

}

func (context *NameContainerParsingContext) Init() {

}

func (encoder *NameContainerEncoder) EncodeInto(value *NameContainer, buf []byte) {

	pos := uint(0)

	if value.Name != nil {
		buf[pos] = byte(7)
		pos += 1
		pos += uint(enc.TLNum(encoder.Name_length).EncodeInto(buf[pos:]))
		for _, c := range value.Name {
			pos += uint(c.EncodeInto(buf[pos:]))
		}
	}
}

func (encoder *NameContainerEncoder) Encode(value *NameContainer) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *NameContainerParsingContext) Parse(reader enc.FastReader, ignoreCritical bool) (*NameContainer, error) {

	var handled_Name bool = false

	progress := -1
	_ = progress

	value := &NameContainer{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 7:
				if true {
					handled = true
					handled_Name = true
					delegate := reader.Delegate(int(l))
					value.Name, err = delegate.ReadName()
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Name && err == nil {
		value.Name = nil
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *NameContainer) Encode() enc.Wire {
	encoder := NameContainerEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *NameContainer) Bytes() []byte {
	return value.Encode().Join()
}

func ParseNameContainer(reader enc.FastReader, ignoreCritical bool) (*NameContainer, error) {
	context := NameContainerParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}
